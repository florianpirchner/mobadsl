/*
 * generated by Xtext 2.9.0.beta6
 */
package org.mobadsl.grammar.validation

import java.util.Collections
import java.util.Set
import org.eclipse.xtext.validation.Check
import org.mobadsl.semantic.model.moba.MobaApplication
import org.mobadsl.semantic.model.moba.MobaBean
import org.mobadsl.semantic.model.moba.MobaConstant
import org.mobadsl.semantic.model.moba.MobaDataType
import org.mobadsl.semantic.model.moba.MobaPackage
import org.mobadsl.semantic.model.moba.MobaPayload
import org.mobadsl.semantic.model.moba.MobaQueue
import org.mobadsl.semantic.model.moba.MobaRestCrud
import org.mobadsl.semantic.model.moba.MobaRestCustom
import org.mobadsl.semantic.model.moba.MobaSettings
import org.mobadsl.semantic.model.moba.RecursionException
import org.mobadsl.semantic.model.moba.MobaTemplate

class MobaValidator extends AbstractMobaValidator {

	public static val DUPLICATE_NAME = 'duplicateName'
	public static val DOWNLOAD_TEMPLATE = 'downloadTemplate'

	@Check
	def checkDuplicateFeatureName(MobaBean dto) {
		// all super type features 
		val superFeatureMap = if (dto.getSuperType != null)
				try {
					dto.getSuperType.allFeatures.toMap [
						it.name
					]
				} catch (RecursionException ex) {
					Collections.emptyMap
				}
			else
				Collections.emptyMap

		val Set<String> currentFeatures = newHashSet()
		var index = 0;
		for (feature : dto.features) {
			if (superFeatureMap.containsKey(feature.name)) {
				error("Supertype contains same feature name", dto, MobaPackage.Literals.MOBA_BEAN__FEATURES, index)
			}

			if (currentFeatures.contains(feature.name)) {
				error("Feature name must be unique", dto, MobaPackage.Literals.MOBA_BEAN__FEATURES, index)
			}
			currentFeatures.add(feature.name)
			index++;
		}

	}

	@Check
	def checkDuplicateFeatureName(MobaPayload payload) {
		// all super type features 
		val superFeatureMap = if (payload.superType != null)
				try {
					payload.superType.allFeatures.toMap [
						it.name
					]
				} catch (RecursionException ex) {
					Collections.emptyMap
				}
			else
				Collections.emptyMap

		val Set<String> currentFeatures = newHashSet()
		var index = 0;
		for (feature : payload.features) {
			if (superFeatureMap.containsKey(feature.name)) {
				error("Supertype contains same feature name", payload, MobaPackage.Literals.MOBA_PAYLOAD__FEATURES,
					index)
			}

			if (currentFeatures.contains(feature.name)) {
				error("Feature name must be unique", payload, MobaPackage.Literals.MOBA_PAYLOAD__FEATURES, index)
			}
			currentFeatures.add(feature.name)
			index++;
		}

	}

	@Check
	def checkDuplicateFeatureName(MobaQueue queue) {
		// all super type features 
		val superFeatureMap = if (queue.superType != null)
				try {
					queue.superType.allFeatures.toMap [
						it.name
					]
				} catch (RecursionException ex) {
					Collections.emptyMap
				}
			else
				Collections.emptyMap

		val Set<String> currentFeatures = newHashSet()
		var index = 0;
		for (feature : queue.features) {
			if (superFeatureMap.containsKey(feature.name)) {
				error("Supertype contains same feature name", queue, MobaPackage.Literals.MOBA_QUEUE__FEATURES, index)
			}

			if (currentFeatures.contains(feature.name)) {
				error("Feature name must be unique", queue, MobaPackage.Literals.MOBA_QUEUE__FEATURES, index)
			}
			currentFeatures.add(feature.name)
			index++;
		}

	}

	@Check
	def checkDuplicateFeatureName(MobaApplication application) {

		// datatypes
		val Set<String> tempConstFeatures = newHashSet()
		val Set<String> tempDtFeatures = newHashSet()
		val Set<String> tempDataFeatures = newHashSet()
		val Set<String> tempServiceFeatures = newHashSet()
		val Set<String> tempSettingsFeatures = newHashSet()
		var index = 0;
		for (feature : application.features) {

			switch (feature) {
				MobaConstant: {
					if (tempConstFeatures.contains(feature.name)) {
						error("Name must be unique", application,
							MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					}
					tempConstFeatures.add(feature.name)
				}
				MobaDataType: {
					if (tempDtFeatures.contains(feature.name)) {
						error("Name must be unique", application,
							MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					}
					tempDtFeatures.add(feature.name)
				}
				MobaBean: {
					if (tempDataFeatures.contains(feature.getName)) {
						error("Name must be unique", application,
							MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					}
					tempDataFeatures.add(feature.getName)
				}
				MobaPayload: {
					if (tempDataFeatures.contains(feature.name)) {
						error("Name must be unique", application,
							MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					}
					tempDataFeatures.add(feature.name)
				}
				MobaQueue: {
					if (tempDataFeatures.contains(feature.name)) {
						error("Name must be unique", application,
							MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					}
					tempDataFeatures.add(feature.name)
				}
				MobaSettings: {
					if (tempSettingsFeatures.contains(feature.name)) {
						error("Feature name must be unique", application,
							MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					}
					tempSettingsFeatures.add(feature.name)
				}
				MobaRestCustom: {
					if (tempServiceFeatures.contains(feature.name)) {
						error("Name must be unique", application,
							MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					}
					tempServiceFeatures.add(feature.name)
				}
				MobaRestCrud: {
					if (tempServiceFeatures.contains(feature.name)) {
						error("Name must be unique", application,
							MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					}
					tempServiceFeatures.add(feature.name)
				}
			}

			index++;
		}
	}

	@Check
	def checkSuperType(MobaBean dto) {
		if (dto.getSuperType == null) {
			return
		}

		try {
			dto.allSuperTypes
		} catch (RecursionException ex) {
			val MobaBean source = ex.source as MobaBean
			val MobaBean superType = ex.superType as MobaBean

			error('''Recursive supertypes for «source.getName» --> «superType.getName»''', dto,
				MobaPackage.Literals.MOBA_BEAN__SUPER_TYPE)
		}

	}

	@Check
	def checkSuperType(MobaPayload payload) {
		if (payload.superType == null) {
			return
		}

		try {
			payload.allSuperTypes
		} catch (RecursionException ex) {
			val MobaPayload source = ex.source as MobaPayload
			val MobaPayload superType = ex.superType as MobaPayload

			error('''Recursive supertypes for «source.name» --> «superType.name»''', payload,
				MobaPackage.Literals.MOBA_PAYLOAD__SUPER_TYPE)
		}
	}

	@Check
	def checkSuperType(MobaQueue queue) {
		if (queue.superType == null) {
			return
		}

		try {
			queue.allSuperTypes
		} catch (RecursionException ex) {
			val MobaQueue source = ex.source as MobaQueue
			val MobaQueue superType = ex.superType as MobaQueue

			error('''Recursive supertypes for «source.name» --> «superType.name»''', queue,
				MobaPackage.Literals.MOBA_QUEUE__SUPER_TYPE)
		}

	}

	@Check
	def checkSettings(MobaApplication application) {
		var activeFound = false
		var firstIndex = -1;
		if (application.settings.size > 1) {
			for (setting : application.settings) {
				if (firstIndex == -1) {
					firstIndex = application.features.indexOf(setting)
				}
				if (activeFound && setting.active) {
					val index = application.features.indexOf(
						setting)
					error('''You are using multiple settings. Please define the active attribute for ONLY one setting.''',
						application, MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					return
				}
				if (!activeFound) {
					activeFound = setting.active
				}
			}

			if (!activeFound) {
				error('''You are using multiple settings. Please define the #active attribute for one setting.''',
					application, MobaPackage.Literals.MOBA_APPLICATION__FEATURES, firstIndex)
			}
		}
	}

	@Check
	def checkGenerators(MobaApplication application) {
		var activeFound = false
		var firstIndex = -1;
		if (application.generators.size > 1) {
			for (generator : application.generators) {
				if (firstIndex == -1) {
					firstIndex = application.features.indexOf(generator)
				}
				if (activeFound && generator.active) {
					val index = application.features.indexOf(
						generator)
					error('''You are using multiple generators. Please define the active attribute for ONLY one generator.''',
						application, MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index)
					return
				}
				if (!activeFound) {
					activeFound = generator.active
				}
			}

			if (!activeFound) {
				error('''You are using multiple generators. Please define the #active attribute for one generator.''',
					application, MobaPackage.Literals.MOBA_APPLICATION__FEATURES, firstIndex)
			}
		}
	}

	@Check
	def checkEnumExtendsNotEnum(MobaDataType datatype) {
		val superType = datatype.superType
		if (!datatype.isEnum || superType == null) {
			return
		}

		if (!superType.isEnum) {
			error('''SuperType «superType.name» is not an Enum''', datatype,
				MobaPackage.Literals.MOBA_DATA_TYPE__ENUM_AST)
		}

	}

	@Check
	def checkEnumExtendsDuplicates(MobaDataType datatype) {
		val superType = datatype.superType
		if (!datatype.isEnum || superType == null) {
			return
		}
		val names = newHashSet()
		val literals = newHashSet()
		val values = newHashSet()
		superType.enumAST.allLiterals.forEach [
			{
				names += it.name
				literals += it.literal
				values += it.value
			}
		]

		datatype.enumAST.literals.forEach [
			if (names.contains(it.name)) {
				error('''Duplicate name "«it.name»." Check super type.''', datatype,
					MobaPackage.Literals.MOBA_DATA_TYPE__ENUM_AST)
			}
			if (literals.contains(it.literal)) {
				error('''Duplicate literal "«it.literal»." Check super type.''', datatype,
					MobaPackage.Literals.MOBA_DATA_TYPE__ENUM_AST)
			}

			if (values.contains(it.value)) {
				warning('''You are redefinging enum literal with value"«it.value»." Check super type.''', datatype,
					MobaPackage.Literals.MOBA_DATA_TYPE__ENUM_AST)
			}
		]
	}

	@Check
	def checkDownloadTemplate(MobaTemplate template) {
		if (!template.downloadTemplate.nullOrEmpty && template.downloadTemplate.startsWith("...index")) {
			error("You need to download the template using the quickfix.", template,
				MobaPackage.Literals.MOBA_TEMPLATE__DOWNLOAD_TEMPLATE, DOWNLOAD_TEMPLATE, null)
		}
	}
}
