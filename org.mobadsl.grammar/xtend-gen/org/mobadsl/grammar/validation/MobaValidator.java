/**
 * generated by Xtext 2.9.0.beta6
 */
package org.mobadsl.grammar.validation;

import com.google.common.base.Objects;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.mobadsl.grammar.validation.AbstractMobaValidator;
import org.mobadsl.semantic.model.moba.MobaApplication;
import org.mobadsl.semantic.model.moba.MobaApplicationFeature;
import org.mobadsl.semantic.model.moba.MobaConstant;
import org.mobadsl.semantic.model.moba.MobaDataType;
import org.mobadsl.semantic.model.moba.MobaDto;
import org.mobadsl.semantic.model.moba.MobaDtoFeature;
import org.mobadsl.semantic.model.moba.MobaEntity;
import org.mobadsl.semantic.model.moba.MobaEntityFeature;
import org.mobadsl.semantic.model.moba.MobaEnum;
import org.mobadsl.semantic.model.moba.MobaEnumLiteral;
import org.mobadsl.semantic.model.moba.MobaGenerator;
import org.mobadsl.semantic.model.moba.MobaPackage;
import org.mobadsl.semantic.model.moba.MobaQueue;
import org.mobadsl.semantic.model.moba.MobaQueueFeature;
import org.mobadsl.semantic.model.moba.MobaRestCrud;
import org.mobadsl.semantic.model.moba.MobaRestCustom;
import org.mobadsl.semantic.model.moba.MobaSettings;
import org.mobadsl.semantic.model.moba.MobaTemplate;
import org.mobadsl.semantic.model.moba.RecursionException;

@SuppressWarnings("all")
public class MobaValidator extends AbstractMobaValidator {
  public final static String DUPLICATE_NAME = "duplicateName";
  
  public final static String DOWNLOAD_TEMPLATE = "downloadTemplate";
  
  @Check
  public void checkDuplicateFeatureName(final MobaEntity dto) {
    Map<String, MobaEntityFeature> _xifexpression = null;
    MobaEntity _superType = dto.getSuperType();
    boolean _notEquals = (!Objects.equal(_superType, null));
    if (_notEquals) {
      Map<String, MobaEntityFeature> _xtrycatchfinallyexpression = null;
      try {
        MobaEntity _superType_1 = dto.getSuperType();
        List<MobaEntityFeature> _allFeatures = _superType_1.getAllFeatures();
        final Function1<MobaEntityFeature, String> _function = (MobaEntityFeature it) -> {
          return it.getName();
        };
        _xtrycatchfinallyexpression = IterableExtensions.<String, MobaEntityFeature>toMap(_allFeatures, _function);
      } catch (final Throwable _t) {
        if (_t instanceof RecursionException) {
          final RecursionException ex = (RecursionException)_t;
          _xtrycatchfinallyexpression = Collections.<String, MobaEntityFeature>emptyMap();
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      _xifexpression = _xtrycatchfinallyexpression;
    } else {
      _xifexpression = Collections.<String, MobaEntityFeature>emptyMap();
    }
    final Map<String, MobaEntityFeature> superFeatureMap = _xifexpression;
    final Set<String> currentFeatures = CollectionLiterals.<String>newHashSet();
    int index = 0;
    EList<MobaEntityFeature> _features = dto.getFeatures();
    for (final MobaEntityFeature feature : _features) {
      {
        String _name = feature.getName();
        boolean _containsKey = superFeatureMap.containsKey(_name);
        if (_containsKey) {
          this.error("Supertype contains same feature name", dto, MobaPackage.Literals.MOBA_ENTITY__FEATURES, index);
        }
        String _name_1 = feature.getName();
        boolean _contains = currentFeatures.contains(_name_1);
        if (_contains) {
          this.error("Feature name must be unique", dto, MobaPackage.Literals.MOBA_ENTITY__FEATURES, index);
        }
        String _name_2 = feature.getName();
        currentFeatures.add(_name_2);
        index++;
      }
    }
  }
  
  @Check
  public void checkDuplicateFeatureName(final MobaDto payload) {
    Map<String, MobaDtoFeature> _xifexpression = null;
    MobaDto _superType = payload.getSuperType();
    boolean _notEquals = (!Objects.equal(_superType, null));
    if (_notEquals) {
      Map<String, MobaDtoFeature> _xtrycatchfinallyexpression = null;
      try {
        MobaDto _superType_1 = payload.getSuperType();
        List<MobaDtoFeature> _allFeatures = _superType_1.getAllFeatures();
        final Function1<MobaDtoFeature, String> _function = (MobaDtoFeature it) -> {
          return it.getName();
        };
        _xtrycatchfinallyexpression = IterableExtensions.<String, MobaDtoFeature>toMap(_allFeatures, _function);
      } catch (final Throwable _t) {
        if (_t instanceof RecursionException) {
          final RecursionException ex = (RecursionException)_t;
          _xtrycatchfinallyexpression = Collections.<String, MobaDtoFeature>emptyMap();
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      _xifexpression = _xtrycatchfinallyexpression;
    } else {
      _xifexpression = Collections.<String, MobaDtoFeature>emptyMap();
    }
    final Map<String, MobaDtoFeature> superFeatureMap = _xifexpression;
    final Set<String> currentFeatures = CollectionLiterals.<String>newHashSet();
    int index = 0;
    EList<MobaDtoFeature> _features = payload.getFeatures();
    for (final MobaDtoFeature feature : _features) {
      {
        String _name = feature.getName();
        boolean _containsKey = superFeatureMap.containsKey(_name);
        if (_containsKey) {
          this.error("Supertype contains same feature name", payload, MobaPackage.Literals.MOBA_DTO__FEATURES, index);
        }
        String _name_1 = feature.getName();
        boolean _contains = currentFeatures.contains(_name_1);
        if (_contains) {
          this.error("Feature name must be unique", payload, MobaPackage.Literals.MOBA_DTO__FEATURES, index);
        }
        String _name_2 = feature.getName();
        currentFeatures.add(_name_2);
        index++;
      }
    }
  }
  
  @Check
  public void checkDuplicateFeatureName(final MobaQueue queue) {
    Map<String, MobaQueueFeature> _xifexpression = null;
    MobaQueue _superType = queue.getSuperType();
    boolean _notEquals = (!Objects.equal(_superType, null));
    if (_notEquals) {
      Map<String, MobaQueueFeature> _xtrycatchfinallyexpression = null;
      try {
        MobaQueue _superType_1 = queue.getSuperType();
        List<MobaQueueFeature> _allFeatures = _superType_1.getAllFeatures();
        final Function1<MobaQueueFeature, String> _function = (MobaQueueFeature it) -> {
          return it.getName();
        };
        _xtrycatchfinallyexpression = IterableExtensions.<String, MobaQueueFeature>toMap(_allFeatures, _function);
      } catch (final Throwable _t) {
        if (_t instanceof RecursionException) {
          final RecursionException ex = (RecursionException)_t;
          _xtrycatchfinallyexpression = Collections.<String, MobaQueueFeature>emptyMap();
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      _xifexpression = _xtrycatchfinallyexpression;
    } else {
      _xifexpression = Collections.<String, MobaQueueFeature>emptyMap();
    }
    final Map<String, MobaQueueFeature> superFeatureMap = _xifexpression;
    final Set<String> currentFeatures = CollectionLiterals.<String>newHashSet();
    int index = 0;
    EList<MobaQueueFeature> _features = queue.getFeatures();
    for (final MobaQueueFeature feature : _features) {
      {
        String _name = feature.getName();
        boolean _containsKey = superFeatureMap.containsKey(_name);
        if (_containsKey) {
          this.error("Supertype contains same feature name", queue, MobaPackage.Literals.MOBA_QUEUE__FEATURES, index);
        }
        String _name_1 = feature.getName();
        boolean _contains = currentFeatures.contains(_name_1);
        if (_contains) {
          this.error("Feature name must be unique", queue, MobaPackage.Literals.MOBA_QUEUE__FEATURES, index);
        }
        String _name_2 = feature.getName();
        currentFeatures.add(_name_2);
        index++;
      }
    }
  }
  
  @Check
  public void checkDuplicateFeatureName(final MobaApplication application) {
    final Set<String> tempConstFeatures = CollectionLiterals.<String>newHashSet();
    final Set<String> tempDtFeatures = CollectionLiterals.<String>newHashSet();
    final Set<String> tempDataFeatures = CollectionLiterals.<String>newHashSet();
    final Set<String> tempServiceFeatures = CollectionLiterals.<String>newHashSet();
    final Set<String> tempSettingsFeatures = CollectionLiterals.<String>newHashSet();
    int index = 0;
    EList<MobaApplicationFeature> _features = application.getFeatures();
    for (final MobaApplicationFeature feature : _features) {
      {
        boolean _matched = false;
        if (!_matched) {
          if (feature instanceof MobaConstant) {
            _matched=true;
            String _name = ((MobaConstant)feature).getName();
            boolean _contains = tempConstFeatures.contains(_name);
            if (_contains) {
              this.error("Name must be unique", application, 
                MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            }
            String _name_1 = ((MobaConstant)feature).getName();
            tempConstFeatures.add(_name_1);
          }
        }
        if (!_matched) {
          if (feature instanceof MobaDataType) {
            _matched=true;
            String _name = ((MobaDataType)feature).getName();
            boolean _contains = tempDtFeatures.contains(_name);
            if (_contains) {
              this.error("Name must be unique", application, 
                MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            }
            String _name_1 = ((MobaDataType)feature).getName();
            tempDtFeatures.add(_name_1);
          }
        }
        if (!_matched) {
          if (feature instanceof MobaEntity) {
            _matched=true;
            String _name = ((MobaEntity)feature).getName();
            boolean _contains = tempDataFeatures.contains(_name);
            if (_contains) {
              this.error("Name must be unique", application, 
                MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            }
            String _name_1 = ((MobaEntity)feature).getName();
            tempDataFeatures.add(_name_1);
          }
        }
        if (!_matched) {
          if (feature instanceof MobaDto) {
            _matched=true;
            String _name = ((MobaDto)feature).getName();
            boolean _contains = tempDataFeatures.contains(_name);
            if (_contains) {
              this.error("Name must be unique", application, 
                MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            }
            String _name_1 = ((MobaDto)feature).getName();
            tempDataFeatures.add(_name_1);
          }
        }
        if (!_matched) {
          if (feature instanceof MobaQueue) {
            _matched=true;
            String _name = ((MobaQueue)feature).getName();
            boolean _contains = tempDataFeatures.contains(_name);
            if (_contains) {
              this.error("Name must be unique", application, 
                MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            }
            String _name_1 = ((MobaQueue)feature).getName();
            tempDataFeatures.add(_name_1);
          }
        }
        if (!_matched) {
          if (feature instanceof MobaSettings) {
            _matched=true;
            String _name = ((MobaSettings)feature).getName();
            boolean _contains = tempSettingsFeatures.contains(_name);
            if (_contains) {
              this.error("Feature name must be unique", application, 
                MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            }
            String _name_1 = ((MobaSettings)feature).getName();
            tempSettingsFeatures.add(_name_1);
          }
        }
        if (!_matched) {
          if (feature instanceof MobaRestCustom) {
            _matched=true;
            String _name = ((MobaRestCustom)feature).getName();
            boolean _contains = tempServiceFeatures.contains(_name);
            if (_contains) {
              this.error("Name must be unique", application, 
                MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            }
            String _name_1 = ((MobaRestCustom)feature).getName();
            tempServiceFeatures.add(_name_1);
          }
        }
        if (!_matched) {
          if (feature instanceof MobaRestCrud) {
            _matched=true;
            String _name = ((MobaRestCrud)feature).getName();
            boolean _contains = tempServiceFeatures.contains(_name);
            if (_contains) {
              this.error("Name must be unique", application, 
                MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            }
            String _name_1 = ((MobaRestCrud)feature).getName();
            tempServiceFeatures.add(_name_1);
          }
        }
        index++;
      }
    }
  }
  
  @Check
  public void checkSuperType(final MobaEntity dto) {
    MobaEntity _superType = dto.getSuperType();
    boolean _equals = Objects.equal(_superType, null);
    if (_equals) {
      return;
    }
    try {
      dto.getAllSuperTypes();
    } catch (final Throwable _t) {
      if (_t instanceof RecursionException) {
        final RecursionException ex = (RecursionException)_t;
        EObject _source = ex.getSource();
        final MobaEntity source = ((MobaEntity) _source);
        EObject _superType_1 = ex.getSuperType();
        final MobaEntity superType = ((MobaEntity) _superType_1);
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Recursive supertypes for ");
        String _name = source.getName();
        _builder.append(_name, "");
        _builder.append(" --> ");
        String _name_1 = superType.getName();
        _builder.append(_name_1, "");
        this.error(_builder.toString(), dto, 
          MobaPackage.Literals.MOBA_ENTITY__SUPER_TYPE);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public void checkSuperType(final MobaDto payload) {
    MobaDto _superType = payload.getSuperType();
    boolean _equals = Objects.equal(_superType, null);
    if (_equals) {
      return;
    }
    try {
      payload.getAllSuperTypes();
    } catch (final Throwable _t) {
      if (_t instanceof RecursionException) {
        final RecursionException ex = (RecursionException)_t;
        EObject _source = ex.getSource();
        final MobaDto source = ((MobaDto) _source);
        EObject _superType_1 = ex.getSuperType();
        final MobaDto superType = ((MobaDto) _superType_1);
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Recursive supertypes for ");
        String _name = source.getName();
        _builder.append(_name, "");
        _builder.append(" --> ");
        String _name_1 = superType.getName();
        _builder.append(_name_1, "");
        this.error(_builder.toString(), payload, 
          MobaPackage.Literals.MOBA_DTO__SUPER_TYPE);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public void checkSuperType(final MobaQueue queue) {
    MobaQueue _superType = queue.getSuperType();
    boolean _equals = Objects.equal(_superType, null);
    if (_equals) {
      return;
    }
    try {
      queue.getAllSuperTypes();
    } catch (final Throwable _t) {
      if (_t instanceof RecursionException) {
        final RecursionException ex = (RecursionException)_t;
        EObject _source = ex.getSource();
        final MobaQueue source = ((MobaQueue) _source);
        EObject _superType_1 = ex.getSuperType();
        final MobaQueue superType = ((MobaQueue) _superType_1);
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Recursive supertypes for ");
        String _name = source.getName();
        _builder.append(_name, "");
        _builder.append(" --> ");
        String _name_1 = superType.getName();
        _builder.append(_name_1, "");
        this.error(_builder.toString(), queue, 
          MobaPackage.Literals.MOBA_QUEUE__SUPER_TYPE);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public void checkSettings(final MobaApplication application) {
    boolean activeFound = false;
    int firstIndex = (-1);
    List<MobaSettings> _settings = application.getSettings();
    int _size = _settings.size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      List<MobaSettings> _settings_1 = application.getSettings();
      for (final MobaSettings setting : _settings_1) {
        {
          if ((firstIndex == (-1))) {
            EList<MobaApplicationFeature> _features = application.getFeatures();
            int _indexOf = _features.indexOf(setting);
            firstIndex = _indexOf;
          }
          boolean _and = false;
          if (!activeFound) {
            _and = false;
          } else {
            boolean _isActive = setting.isActive();
            _and = _isActive;
          }
          if (_and) {
            EList<MobaApplicationFeature> _features_1 = application.getFeatures();
            final int index = _features_1.indexOf(setting);
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("You are using multiple settings. Please define the active attribute for ONLY one setting.");
            this.error(_builder.toString(), application, MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            return;
          }
          if ((!activeFound)) {
            boolean _isActive_1 = setting.isActive();
            activeFound = _isActive_1;
          }
        }
      }
      if ((!activeFound)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("You are using multiple settings. Please define the #active attribute for one setting.");
        this.error(_builder.toString(), application, MobaPackage.Literals.MOBA_APPLICATION__FEATURES, firstIndex);
      }
    }
  }
  
  @Check
  public void checkGenerators(final MobaApplication application) {
    boolean activeFound = false;
    int firstIndex = (-1);
    List<MobaGenerator> _generators = application.getGenerators();
    int _size = _generators.size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      List<MobaGenerator> _generators_1 = application.getGenerators();
      for (final MobaGenerator generator : _generators_1) {
        {
          if ((firstIndex == (-1))) {
            EList<MobaApplicationFeature> _features = application.getFeatures();
            int _indexOf = _features.indexOf(generator);
            firstIndex = _indexOf;
          }
          boolean _and = false;
          if (!activeFound) {
            _and = false;
          } else {
            boolean _isActive = generator.isActive();
            _and = _isActive;
          }
          if (_and) {
            EList<MobaApplicationFeature> _features_1 = application.getFeatures();
            final int index = _features_1.indexOf(generator);
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("You are using multiple generators. Please define the active attribute for ONLY one generator.");
            this.error(_builder.toString(), application, MobaPackage.Literals.MOBA_APPLICATION__FEATURES, index);
            return;
          }
          if ((!activeFound)) {
            boolean _isActive_1 = generator.isActive();
            activeFound = _isActive_1;
          }
        }
      }
      if ((!activeFound)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("You are using multiple generators. Please define the #active attribute for one generator.");
        this.error(_builder.toString(), application, MobaPackage.Literals.MOBA_APPLICATION__FEATURES, firstIndex);
      }
    }
  }
  
  @Check
  public void checkEnumExtendsNotEnum(final MobaDataType datatype) {
    final MobaDataType superType = datatype.getSuperType();
    boolean _or = false;
    boolean _isEnum = datatype.isEnum();
    boolean _not = (!_isEnum);
    if (_not) {
      _or = true;
    } else {
      boolean _equals = Objects.equal(superType, null);
      _or = _equals;
    }
    if (_or) {
      return;
    }
    boolean _isEnum_1 = superType.isEnum();
    boolean _not_1 = (!_isEnum_1);
    if (_not_1) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("SuperType ");
      String _name = superType.getName();
      _builder.append(_name, "");
      _builder.append(" is not an Enum");
      this.error(_builder.toString(), datatype, 
        MobaPackage.Literals.MOBA_DATA_TYPE__ENUM_AST);
    }
  }
  
  @Check
  public void checkEnumExtendsDuplicates(final MobaDataType datatype) {
    final MobaDataType superType = datatype.getSuperType();
    boolean _or = false;
    boolean _isEnum = datatype.isEnum();
    boolean _not = (!_isEnum);
    if (_not) {
      _or = true;
    } else {
      boolean _equals = Objects.equal(superType, null);
      _or = _equals;
    }
    if (_or) {
      return;
    }
    final HashSet<String> names = CollectionLiterals.<String>newHashSet();
    final HashSet<String> literals = CollectionLiterals.<String>newHashSet();
    final HashSet<Integer> values = CollectionLiterals.<Integer>newHashSet();
    MobaEnum _enumAST = superType.getEnumAST();
    List<MobaEnumLiteral> _allLiterals = _enumAST.getAllLiterals();
    final Consumer<MobaEnumLiteral> _function = (MobaEnumLiteral it) -> {
      String _name = it.getName();
      names.add(_name);
      String _literal = it.getLiteral();
      literals.add(_literal);
      int _value = it.getValue();
      values.add(Integer.valueOf(_value));
    };
    _allLiterals.forEach(_function);
    MobaEnum _enumAST_1 = datatype.getEnumAST();
    EList<MobaEnumLiteral> _literals = _enumAST_1.getLiterals();
    final Consumer<MobaEnumLiteral> _function_1 = (MobaEnumLiteral it) -> {
      String _name = it.getName();
      boolean _contains = names.contains(_name);
      if (_contains) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Duplicate name \"");
        String _name_1 = it.getName();
        _builder.append(_name_1, "");
        _builder.append(".\" Check super type.");
        this.error(_builder.toString(), datatype, 
          MobaPackage.Literals.MOBA_DATA_TYPE__ENUM_AST);
      }
      String _literal = it.getLiteral();
      boolean _contains_1 = literals.contains(_literal);
      if (_contains_1) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Duplicate literal \"");
        String _literal_1 = it.getLiteral();
        _builder_1.append(_literal_1, "");
        _builder_1.append(".\" Check super type.");
        this.error(_builder_1.toString(), datatype, 
          MobaPackage.Literals.MOBA_DATA_TYPE__ENUM_AST);
      }
      int _value = it.getValue();
      boolean _contains_2 = values.contains(Integer.valueOf(_value));
      if (_contains_2) {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("You are redefinging enum literal with value\"");
        int _value_1 = it.getValue();
        _builder_2.append(_value_1, "");
        _builder_2.append(".\" Check super type.");
        this.warning(_builder_2.toString(), datatype, 
          MobaPackage.Literals.MOBA_DATA_TYPE__ENUM_AST);
      }
    };
    _literals.forEach(_function_1);
  }
  
  @Check
  public void checkDownloadTemplate(final MobaTemplate template) {
    boolean _and = false;
    String _downloadTemplate = template.getDownloadTemplate();
    boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_downloadTemplate);
    boolean _not = (!_isNullOrEmpty);
    if (!_not) {
      _and = false;
    } else {
      String _downloadTemplate_1 = template.getDownloadTemplate();
      boolean _startsWith = _downloadTemplate_1.startsWith("...index");
      _and = _startsWith;
    }
    if (_and) {
      this.error("You need to download the template using the quickfix.", template, 
        MobaPackage.Literals.MOBA_TEMPLATE__DOWNLOAD_TEMPLATE, MobaValidator.DOWNLOAD_TEMPLATE, null);
    }
  }
}
